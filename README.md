### Вопросы:
#### Что такое переменная в Python?
1. Как работает области видимости в python? Что такое LEGB в python (LEGB — Local, Enclosing, Global, Built-in)?
	- **Local (локальная область)**: Переменные, определённые внутри текущей функции или блока кода.
	- **Enclosing (вложенная область)**: Переменные, находящиеся в локальной области внешней функции для текущей вложенной функции. Применяется для замыканий (closures).
	- **Global (глобальная область)**: Переменные, определённые на уровне модуля, то есть вне функций. Если переменная объявлена глобальной, её можно использовать и изменять внутри функций с помощью ключевого слова `global`.
	- **Built-in (встроенная область)**: Это область встроенных функций и переменных, таких как `print`, `len`, и т.д., доступная всегда.
	1. Как Python обрабатывает глобальные и локальные переменные?
		- **Локальные переменные**: Определены внутри функций или блоков кода (например, внутри цикла). Они существуют только в пределах функции или блока. После завершения выполнения функции эти переменные больше недоступны.
		- **Глобальные переменные**: Определены на уровне модуля (вне функций или классов). Они доступны в любой функции модуля, но могут быть изменены внутри функции только с использованием ключевого слова `global`.
	2. Чем отличается область видимости внутри функции, цикла или класса?
		**Область видимости внутри функции**: Это **локальная область видимости**. Переменные, объявленные внутри функции, существуют только в пределах этой функции и недоступны за её пределами. Локальная область видимости создаётся при каждом вызове функции.
		**Область видимости внутри цикла**: В Python переменные, объявленные внутри цикла, попадают в ту же область видимости, что и сам цикл, обычно это локальная область, если цикл находится в функции, или глобальная, если цикл вне функции. Они сохраняются после завершения цикла.
		**Область видимости внутри класса**: Переменные, объявленные внутри методов класса, ведут себя как локальные переменные. Однако переменные, объявленные на уровне класса, доступны как атрибуты класса и экземпляров класса.
2. Какие есть стили нейминга переменных в python? Чем отличается стиль именования переменных в Python от других языков (PEP 8)?
	1. Нейминг:
		1. snake_case
		2. CamelCase
#### Какие типы данных существуют в Python? Как они классифицируются?
##### Numbers (числа)
##### Strings (строки)
##### Boolean (логический тип данных)
##### Lists (списки)
Списки — это изменяемые последовательности элементов, которые могут содержать разные типы данных

Списки изменяемы, что позволяет вам добавлять, удалять и изменять элементы после их создания.
**Методы изменения:**
- **append()**: Добавляет элемент в конец списка.
- **extend()**: Расширяет список, добавляя элементы из другого итерируемого объекта.
- **insert()**: Вставляет элемент по указанному индексу.
- **remove()**: Удаляет первый найденный элемент с указанным значением.
- **pop()**: Удаляет элемент по указанному индексу и возвращает его. Если индекс не указан, удаляет последний элемент.
- **clear()**: Очищает все элементы списка.
Списки поддерживают множество встроенных методов, которые упрощают работу с ними:
- **count(x)**: Возвращает количество вхождений элемента `x` в список.
- **index(x)**: Возвращает индекс первого вхождения элемента `x`.
- **sort()**: Сортирует элементы списка на месте.
- **reverse()**: Обращает порядок элементов в списке.
- **copy()**: Возвращает поверхностную копию списка.

Списки в Python динамически выделяют память. Это означает, что при добавлении или удалении элементов размер списка может изменяться. Python автоматически управляет выделением и освобождением памяти.
##### Dictionaries (словари)
Словари представляют собой коллекции пар "ключ-значение"

Словари в Python имеют множество встроенных методов, которые позволяют выполнять различные операции:
- **keys()**: Возвращает все ключи словаря.
- **values()**: Возвращает все значения словаря.
- **items()**: Возвращает все пары (ключ, значение) в виде кортежей.
- **clear()**: Очищает словарь.
- **update()**: Обновляет словарь, добавляя элементы из другого словаря или итерируемого объекта.
- **get()**: Получает значение по ключу

**Применение словарей**
Словари часто используются для:
- Хранения связанных данных (например, свойства объектов).
- Быстрого поиска значений по ключам.
- Упрощения обработки данных в виде пар ключ-значение.
##### Tuples (кортежи)
Кортежи — это неизменяемые последовательности

**Применение кортежей**
Кортежи часто используются для:
- Хранения фиксированных наборов значений (например, координаты).
- Возвращения нескольких значений из функции.
- Использования в качестве ключей в словарях (поскольку кортежи являются неизменяемыми).
##### Sets (множества)
Множества (или `sets`) в Python — это неупорядоченные коллекции уникальных элементов, которые используются для хранения множества значений. Они предоставляют эффективные способы выполнения операций, связанных с математическими множествами, таких как объединение, пересечение и разность. Давайте подробнее рассмотрим множества.

Множества поддерживают различные операции, которые можно использовать для выполнения различных задач:
- **Объединение (`union`)**: Объединяет два множества, возвращая новое множество с элементами из обоих множеств.
- **Пересечение (`intersection`)**: Возвращает новое множество, содержащее только элементы, которые присутствуют в обоих множествах.
- **Разность (`difference`)**: Возвращает новое множество, содержащее элементы, которые есть в первом множестве, но отсутствуют во втором.
- **Симметричная разность (`symmetric_difference`)**: Возвращает новое множество, содержащее элементы, которые есть только в одном из множеств.
**Методы:**
- **add(x)**: Добавляет элемент `x` в множество.
- **remove(x)**: Удаляет элемент `x` из множества. Вызывает ошибку `KeyError`, если элемента нет.
- **discard(x)**: Удаляет элемент `x` из множества, но не вызывает ошибку, если элемента нет.
- **clear()**: Очищает множество.
- **copy()**: Создает поверхностную копию множества.

**Применение множеств**
Множества часто используются для:
- Устранения дубликатов из последовательностей.
- Выполнения математических операций над множествами.
- Быстрого поиска и проверки принадлежности.
##### Типы данных
- изменяемые (списки, словари и множества)
- неизменяемые (числа, строки и кортежи)
- упорядоченные (списки, кортежи, строки и словари)
- неупорядоченные (множества)

1. Чем отличаются изменяемые (mutable) и неизменяемые (immutable) типы данных?
	1. Какие встроенные типы данных являются изменяемыми, а какие — неизменяемыми?
	2. Почему строки (str) и кортежи (tuple) являются неизменяемыми, а списки (list) и словари (dict) — изменяемыми?
	3. Как изменение значений изменяемого объекта внутри функции влияет на его поведение вне функции?
2. Как Python управляет памятью для различных типов данных?
	1. Как работает механизм управления памятью в Python (сборка мусора, подсчет ссылок)?
	2. Почему неизменяемые типы данных, такие как кортежи, могут делиться памятью между объектами?
	3. Как Python избегает дублирования неизменяемых объектов с одинаковым значением (например, интернирование строк)?
3. Что такое хэшируемые (hashable) объекты, и почему это важно для некоторых структур данных?
	1. Какие типы данных являются хэшируемыми и почему это важно для использования в таких структурах, как множества и словари?
	2. Как изменяемость объекта влияет на его хэшируемость?
	3. Как работают методы `__hash__()` и `__eq__()` в контексте хэшируемых объектов?
#### Что такое функции в Python?
- Что такое **параметры** и **аргументы**? В чем разница между ними?
- Каковы особенности использования аргументов по умолчанию в функциях?
- Что такое **анонимные функции (лямбда-функции)** и как они используются в Python?
	- Это функции, которые не имеют имени и создаются с использованием ключевого слова `lambda`.
	- Они могут принимать любое количество аргументов, но могут содержать только одно выражение.
	- Лямбда-функции делают код компактнее и удобнее для написания небольших функций, которые используются одноразово.
- Что такое замыкание и как оно работает в Python? Приведите пример, где замыкание может быть полезно.
	- **Замыкание** (closure) — это функция, которая «запоминает» свое окружение даже после того, как внешняя функция, в которой она была определена, завершила выполнение. Замыкания позволяют внутренней функции доступ к переменным внешней функции.
	- **Пример:** Кэширование позволяет сохранять результаты вычислений и использовать их повторно, избегая лишних затрат на обработку. Это может быть полезно, например, при запросах к API.
#### Что такое классы и объекты в Python?
**Класс** — это шаблон (или чертеж) для создания объектов. Он определяет, какие свойства (атрибуты) и методы (функции) будут у созданных на его основе объектов. Классы помогают организовать код и реализовать принципы объектно-ориентированного программирования (ООП).
**Объект** — это экземпляр класса, который создан на основе этого шаблона. Объект может иметь свои собственные значения для атрибутов, определенных в классе, и может использовать методы этого класса.
##### Что такое конструктор и как он работает в Python?
- **Ответ**: Конструктор — это специальный метод `__init__`, который вызывается при создании нового объекта. Он используется для инициализации атрибутов объекта.
##### Как работает ООП в Python?
- **Что такое инкапсуляция и как она реализуется в Python?**
	- **Ответ**: Инкапсуляция — это принцип ООП, который скрывает детали реализации объекта и защищает его состояние от некорректных изменений. В Python это можно сделать с помощью атрибутов, начинающихся с одного или двух подчеркиваний.
- **Что такое наследование в Python?**
	- **Ответ**: Наследование позволяет создавать новый класс на основе уже существующего, унаследовав его атрибуты и методы. Это способствует повторному использованию кода.
- **Что такое полиморфизм в Python?**
	- **Ответ**: Полиморфизм позволяет использовать один и тот же интерфейс для объектов разных классов. Это значит, что методы могут иметь одно имя, но разное поведение в разных классах.

#### Как работает обработка исключений в Python?
Обработка исключений позволяет управлять ошибками, которые могут возникнуть в программе, обеспечивая ее стабильность и предсказуемость. Это достигается с помощью блоков `try`, `except`, `else` и `finally`.
1. Как использовать блоки `try`, `except`, `else`, `finally` для обработки ошибок?
	- **Ответ:**
		- `try`: блок кода, который может вызвать исключение.
		- `except`: блок кода, который выполняется, если в блоке `try` произошло исключение.
		- `else`: (опционально) блок, который выполняется, если в блоке `try` не произошло исключения.
		- `finally`: (опционально) блок кода, который выполняется в любом случае, независимо от того, произошло исключение или нет.
2. Как создавать собственные классы исключений и когда это необходимо?
	- **Ответ**: Создание собственных классов исключений позволяет более точно обрабатывать специфические ошибки в вашем приложении. Обычно это делается путем наследования от встроенного класса `Exception`.
3. Чем отличается исключение от ошибки в коде?
	- **Ответ**: Исключение — это специфическая ошибка, которую программа может обработать во время выполнения. Ошибка в коде, как правило, относится к синтаксическим ошибкам, которые предотвращают выполнение программы. Исключения могут быть вызваны различными ситуациями, такими как деление на ноль, ошибки ввода/вывода и т. д.
#### Как работают декораторы в Python и для чего они нужны?
Декораторы — это специальные функции, которые позволяют изменять поведение других функций или методов без изменения их исходного кода.
1. Как создать функцию-декоратор, и что она делает?
	- **Ответ**: Декоратор — это функция, принимающая другую функцию в качестве аргумента и возвращающая новую функцию. Это позволяет оборачивать оригинальную функцию и добавлять дополнительный функционал.
2. Как декораторы могут изменять поведение функции, не изменяя исходный код?
	- **Ответ**: Декораторы позволяют добавлять или изменять функциональность функций, оборачивая их в другую функцию. Это дает возможность внедрять дополнительные действия, такие как логирование, проверка доступа, кэширование и т. д., не изменяя оригинальную реализацию функции.
3. Чем полезны встроенные декораторы, такие как `@staticmethod`, `@classmethod`, и как они работают?
	- **Ответ**:
		- `@staticmethod`: используется для определения статических методов, которые не требуют ссылки на экземпляр класса или сам класс. Эти методы могут быть вызваны через класс или экземпляр.
		- `@classmethod`: используется для определения методов, которые принимают класс как первый аргумент (`cls`), что позволяет изменять состояние класса, а не только состояние экземпляра.



#### Многопоточность и асинхронное программирование
- **I/O-bound**: время ожидания операций ввода-вывода (например, доступ к сети или диску) является основным ограничением производительности.
- **CPU-bound**: ограничение производительности связано с вычислительной мощностью процессора, и время выполнения задач зависит от их сложности и потребления ресурсов.
##### Что такое многопоточность? Что такое асинхронное программирование?
- **Многопоточность** — это способ выполнения нескольких потоков (параллельных потоков выполнения) в рамках одной программы. Она позволяет программе выполнять несколько задач одновременно, что может улучшить производительность, особенно при выполнении операций ввода-вывода (I/O).
- **Асинхронное программирование** — это подход к выполнению задач, при котором код может продолжать выполняться, не дожидаясь завершения длительных операций (например, операций ввода-вывода). Это достигается путем использования коллбеков, промисов или ключевых слов `async` и `await`, что позволяет выполнять другие задачи, пока ожидается результат.
##### Как в Python работает многопоточность?
В Python для создания потоков используется модуль `threading`. Каждый поток выполняется в рамках одного процесса, и Python использует GIL (Global Interpreter Lock), который позволяет только одному потоку выполнять байт-код Python в один момент времени. Это значит, что многопоточность в Python не всегда приводит к значительному увеличению производительности для CPU-bound задач, но может быть полезна для I/O-bound задач, где время ожидания может быть использовано другими потоками.

##### Что такое GIL в python?
**GIL (Global Interpreter Lock)** — это механизм синхронизации в CPython (основной реализации Python), который ограничивает выполнение потоков в интерпретаторе Python.
###### Основные аспекты GIL:
1. **Что такое GIL?**
    - GIL — это глобальная блокировка, которая гарантирует, что в любой момент времени только один поток выполняет байт-код Python. Это означает, что даже если программа использует многопоточность, только один поток может выполняться в момент времени.
2. **Зачем нужен GIL?**
    - GIL упрощает управление памятью и обеспечивает безопасность данных в многопоточных приложениях, так как не требуется сложная блокировка при работе с объектами Python.
3. **Проблемы GIL:**
    - **Проблемы производительности**: GIL может стать узким местом для CPU-bound задач, так как они не могут использовать преимущества многоядерных процессоров. Потоки не могут эффективно параллелизовать вычисления, что может снизить производительность.
    - **Многопоточность**: Для I/O-bound задач, которые требуют ожидания (например, сетевые операции), GIL не так критичен, поскольку потоки могут переключаться во время ожидания.
4. **Обход GIL:**
    - Для задач, требующих высокой производительности, разработчики могут использовать многопроцессорность (модуль `multiprocessing`), что позволяет создавать отдельные процессы, каждый из которых имеет свой собственный GIL. Это позволяет эффективно использовать многоядерные процессоры.
5. **Альтернативы**:
    - Некоторые альтернативные реализации Python (например, Jython и IronPython) не имеют GIL и могут эффективно использовать многопоточность. Однако они не поддерживают все библиотеки CPython.
##### Чем потоки в Python отличаются от потоков в операционной системе?
- **Потоки в Python** (через `threading`) управляются интерпретатором Python и подвержены GIL, что означает, что только один поток может выполнять код Python в один момент времени. Это ограничивает многопоточность для задач, требующих интенсивных вычислений.
- **Потоки в операционной системе** — это нативные потоки, которые могут выполняться параллельно на разных ядрах процессора, не имея ограничений GIL. Это позволяет эффективно использовать многоядерные процессоры для выполнения параллельных задач.
##### Какие есть примитивы синхронизации в Python
- **Блокировки (Locks)** — используются для предотвращения одновременного доступа к общему ресурсу. Они обеспечивают механизм «взаимного исключения» (mutual exclusion).
- **Семафоры (Semaphores)** — это более сложные примитивы, которые позволяют ограничить количество потоков, имеющих доступ к ресурсу.
- **События (Events)** — используются для сигнализации между потоками, чтобы один поток мог ожидать выполнения определенного условия.
- **Очереди (Queues)** — предоставляют потокобезопасный способ обмена данными между потоками.
##### Что такое `event loop` и как он работает в асинхронном программировании?
- **Цикл событий (Event Loop)** — это основной компонент асинхронного программирования в Python, который управляет выполнением асинхронных задач. Он обрабатывает корутины и задачи, которые должны выполняться, и следит за их состоянием.
- При использовании `asyncio`, цикл событий отвечает за планирование выполнения корутин, управление их состоянием и обработку I/O операций. Когда корутина ожидает завершения операции (например, чтения из файла или сетевого запроса), цикл событий может переключаться на выполнение других корутин, тем самым обеспечивая асинхронное поведение.
##### Какие проблемы могут возникнуть при использовании асинхронного программмирования?
- **Сложность отладки**:
    - Асинхронный код может быть сложнее отлаживать из-за непредсказуемого порядка выполнения.
- **Состояние гонки (Race Condition)**:
    - Несколько корутин могут одновременно изменять общие данные, что приводит к непредсказуемым результатам.
- **Дедлок (Deadlock)**:
    - Кортины могут блокироваться в ожидании друг друга, что останавливает выполнение программы.
- **Утечки памяти**:
    - Кортины могут оставлять ссылки на объекты, что мешает сборщику мусора освободить их.
- **Проблемы с совместимостью библиотек**:
    - Не все библиотеки поддерживают асинхронное программирование, что может ограничить выбор инструментов.
- **Проблемы с производительностью**:
    - Неправильное использование асинхронности может привести к ухудшению производительности.
#### Задачи:
##### Переменные
```python
  # Задача 1. Переменные.
  # Какой результат выведет программа? Как изменяется переменная x на каждом этапе?
  # Объясни разницу между использованием global и nonlocal.
	#	Почему значение переменной x внутри outer_function() не затрагивает глобальную переменную x?
  
  x = 10 

  def outer_function():
      x = 5 
      def modify_variable():
          nonlocal x 
          x += 1
          print(f"Inside modify_variable: {x}")

      def delayed_execution():
          print(f"delayed_execution_1: {x}")
          modify_variable()
          print(f"delayed_execution_2: {x}")
	  
      delayed_execution()
      
      delayed_execution()

  outer_function()
  print(f"x: {x}")

```

##### Палиндром:

```python
def is_palindrome(s): 
	# code is here
	pass
	

print(is_palindrome("A man a plan a canal Panama")) # True
print(is_palindrome("hello")) # False
```
##### Сортировка пузырьком
**Определение**: Сортировка пузырьком (Bubble Sort) — это простой алгоритм сортировки, который последовательно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот процесс повторяется до тех пор, пока весь список не будет отсортирован.
###### Принцип работы:
1. **Проход по списку**: Алгоритм начинает с первого элемента и сравнивает его со следующим.
2. **Сравнение и обмен**: Если текущий элемент больше следующего, они меняются местами.
3. **Пузырьковый эффект**: После первого прохода наибольший элемент "всплывает" в конец списка, как пузырек в воде. Это и дало название алгоритму.
4. **Повторение**: Процесс повторяется для оставшейся части списка, исключая уже отсортированные элементы в конце.
5. **Завершение**: Алгоритм завершает работу, когда проходит по всему списку и не делает ни одного обмена (то есть список отсортирован).

###### Пример:
Рассмотрим массив: `[5, 2, 9, 1, 5, 6]`.
1. **Первый проход**:
    - Сравниваем 5 и 2 → меняем → `[2, 5, 9, 1, 5, 6]`
    - Сравниваем 5 и 9 → не меняем
    - Сравниваем 9 и 1 → меняем → `[2, 5, 1, 9, 5, 6]`
    - Сравниваем 9 и 5 → меняем → `[2, 5, 1, 5, 9, 6]`
    - Сравниваем 9 и 6 → меняем → `[2, 5, 1, 5, 6, 9]
   После первого прохода наибольший элемент (9) оказался в конце списка.
2. **Второй проход**:
    - Сравниваем 2 и 5 → не меняем
    - Сравниваем 5 и 1 → меняем → `[2, 1, 5, 5, 6, 9]`
    - Сравниваем 5 и 5 → не меняем
    - Сравниваем 5 и 6 → не меняем
    После второго прохода 6 также оказался на своем месте.
3. **Третий проход**:
    - Сравниваем 2 и 1 → меняем → `[1, 2, 5, 5, 6, 9]`
    - Все остальные элементы на своих местах.
Теперь массив отсортирован: `[1, 2, 5, 5, 6, 9]`.`
###### Сложность алгоритма:
- **Временная сложность**: В худшем и среднем случаях — O(n²), где n — количество элементов в списке. В лучшем случае (если массив уже отсортирован) — O(n).
- **Пространственная сложность**: O(1), так как сортировка выполняется на месте и не требует дополнительной памяти для хранения элементов.
###### Применение:
Сортировка пузырьком используется в основном для учебных целей, чтобы объяснить основные концепции алгоритмов сортировки. На практике для сортировки больших массивов она обычно не используется из-за низкой эффективности по сравнению с другими алгоритмами, такими как быстрая сортировка (Quick Sort) или сортировка слиянием (Merge Sort).

###### Реализация
```python
def bubble_sort(arr):
	# your code is here
    pass

# Пример использования
numbers = [64, 34, 25, 12, 22, 11, 90]
sorted_numbers = bubble_sort(numbers)
print(sorted_numbers)  # Вывод: [11, 12, 22, 25, 34, 64, 90]

```

